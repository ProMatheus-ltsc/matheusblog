(window.webpackJsonp=window.webpackJsonp||[]).push([[181],{1465:function(s,a,n){"use strict";n.r(a);var t=n(24),e=Object(t.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[s._v("#")]),s._v(" 简介")]),s._v(" "),n("h2",{attrs:{id:"背景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[s._v("#")]),s._v(" 背景")]),s._v(" "),n("p",[s._v("随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。")]),s._v(" "),n("p",[s._v("在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。")]),s._v(" "),n("p",[s._v("逃逸分析技术到现在还不是很成熟，虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。")]),s._v(" "),n("h2",{attrs:{id:"何为逃逸分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#何为逃逸分析"}},[s._v("#")]),s._v(" 何为逃逸分析")]),s._v(" "),n("p",[s._v("逃逸分析一种数据分析算法，基于此算法可以有效减少Java对象在堆内存中的分配。Hotspot虚拟机的编译器能够分析出一个新对象的引用范围，然后决定是否要将这个对象分配到堆上。例如：\n1)当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。\n2)当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。")]),s._v(" "),n("h1",{attrs:{id:"逃逸分析案例演示"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#逃逸分析案例演示"}},[s._v("#")]),s._v(" 逃逸分析案例演示")]),s._v(" "),n("h2",{attrs:{id:"逃逸对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#逃逸对象"}},[s._v("#")]),s._v(" 逃逸对象")]),s._v(" "),n("p",[s._v("如下代码中的StringBuffer发生了逃逸，不会在栈上分配。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public StringBuffer append(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb;\n}\n123456\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[s._v("可以调整为如下写法，例如：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public StringBuffer append(String s1, String s2) {\n    StringBuffer sb = new StringBuffer();\n    sb.append(s1);\n    sb.append(s2);\n    return sb.toString();\n}\n123456\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("h2",{attrs:{id:"未逃逸对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#未逃逸对象"}},[s._v("#")]),s._v(" 未逃逸对象")]),s._v(" "),n("p",[s._v("当一个对象在方法内创建，又没有被外界引用，此对象为为逃逸对象。例如：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public void create(int x,int y) {\n    Point p1= new Point(x,y);\n    //…\n    p1=null;\n   \n}\n123456\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("h2",{attrs:{id:"逃逸分析参数设置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#逃逸分析参数设置"}},[s._v("#")]),s._v(" 逃逸分析参数设置")]),s._v(" "),n("p",[s._v("在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析，如果使用的是较早的版本，开发人员则可以通过：")]),s._v(" "),n("p",[s._v('1）选项“-XX:+DoEscapeAnalysis"显式开启逃逸分析。\n2）通过选项“-XX:+PrintEscapeAnalysis"查看逃逸分析的筛选结果。')]),s._v(" "),n("p",[s._v("建议：开发中能在方法内部应用对象的，就尽量控制在内部。")]),s._v(" "),n("h1",{attrs:{id:"代码优化实践"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码优化实践"}},[s._v("#")]),s._v(" 代码优化实践")]),s._v(" "),n("h2",{attrs:{id:"概述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[s._v("#")]),s._v(" 概述")]),s._v(" "),n("p",[s._v("使用逃逸分析，编译器可以对代码做如下优化：")]),s._v(" "),n("p",[s._v("1）栈上分配：将堆分配转化为栈分配。如果一个对象在方法内创建，要使指向该对象的引用不会发生逃逸，对象可能是栈上分配的候选。")]),s._v(" "),n("p",[s._v("2）同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。")]),s._v(" "),n("p",[s._v("3） 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。")]),s._v(" "),n("h2",{attrs:{id:"栈上分配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈上分配"}},[s._v("#")]),s._v(" 栈上分配")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('/**\n * 栈上分配测试(-XX:-DoEscapeAnalysis)\n * -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails\n */\npublic class ObjectStackAllocationTests {\n    public static void main(String[] args) throws InterruptedException {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 10000000; i++) {\n            alloc();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println("花费的时间为： " + (end - start) + " ms");\n        // 为了方便查看堆内存中对象个数，线程sleep\n        TimeUnit.MINUTES.sleep(5);\n    }\n    private static void alloc() {\n        byte[] data = new byte[10];//未发生逃逸\n    }\n}\n12345678910111213141516171819\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br")])]),n("p",[s._v("对如上代码运行测试时，分别开启和关闭逃逸分析，检查控制台日志的输出以及花费时间上的不同。")]),s._v(" "),n("h2",{attrs:{id:"同步锁消除"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#同步锁消除"}},[s._v("#")]),s._v(" 同步锁消除")]),s._v(" "),n("p",[s._v("我们知道线程同步是靠牺牲性能来保证数据的正确性，这个过程的代价会非常高。程序的并发行和性能都会降低。JVM的JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程应用？假如是，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码上加的锁。这个取消同步的过程就叫同步省略，也叫锁消除。例如：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("public class SynchronizedLockTest {\n    public void lock() {\n        Object obj= new Object();\n        synchronized(obj) {\n            System.out.println(obj);\n        }\n    }\n}\n12345678\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br")])]),n("h2",{attrs:{id:"标量替换分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#标量替换分析"}},[s._v("#")]),s._v(" 标量替换分析")]),s._v(" "),n("p",[s._v("所谓的标量（scalar）一般指的是一个无法再分解成更小数据的数据。例如，Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象分解成若干个变量来代替。这个过程就是标量替换。例如：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('package com.java.jvm;\n/**\n * 标量替换测试 （-XX:+EliminateAllocations）\n * -Xmx128m -Xms128m -XX:+DoEscapeAnalysis \n-XX:+PrintGC -XX:-EliminateAllocations \n */\npublic class ObjectScalarReplaceTests {\n\n    public static void main(String args[]) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 10000000; i++) {\n            alloc();\n        }\n        long end = System.currentTimeMillis();\n        System.out.println("花费的时间为： " + (end - start) + " ms");\n    }\n\n    private static void alloc() {\n        Point point = new Point(1,2);\n    }\n\n    static class Point {\n        private int x;\n        private int y;\n        public Point(int x,int y){\n            this.x=x;\n            this.y=y;\n        }\n    }\n}\n123456789101112131415161718192021222324252627282930\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br")])]),n("p",[s._v("对于上面代码，假如开启了标量替换，那么alloc方法的内容就会变为如下形式：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("private static void alloc() {\n          int x=10;\nint y=20;\n    }\n1234\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("alloc方法内部的Point对象是一个聚合量，这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。标量替换为栈上分配提供了很好的基础。")]),s._v(" "),n("h1",{attrs:{id:"小节面试分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小节面试分析"}},[s._v("#")]),s._v(" 小节面试分析")]),s._v(" "),n("p",[s._v("1）什么是逃逸分析？\n2）逃逸分析有什么优势、劣势？\n3）什么是栈上分配,为什么要栈上分配？\n4）什么是锁消除，何时会触发锁消除？\n5）什么是标量替换，标量替换可以解决什么问题？\n6）Hotspot虚拟机中所有对象都是分配在堆中吗？(是的)\n7HotSpot虚拟机中对象的栈上分配如何理解？（本质上是标量替换）")])])}),[],!1,null,null,null);a.default=e.exports}}]);